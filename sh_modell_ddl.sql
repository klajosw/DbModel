-- Generated by Oracle SQL Developer Data Modeler 19.2.0.182.1216
--   at:        2020-10-04 16:53:32 CEST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



CREATE TABLE channels (
    channel_id         NUMBER NOT NULL,
    channel_desc       VARCHAR2(20 BYTE) NOT NULL,
    channel_class      VARCHAR2(20 BYTE) NOT NULL,
    channel_class_id   NUMBER NOT NULL,
    channel_total      VARCHAR2(13 BYTE) NOT NULL,
    channel_total_id   NUMBER NOT NULL
)
LOGGING
    ENABLE ROW MOVEMENT;

COMMENT ON COLUMN channels.channel_id IS
    'primary key column';

COMMENT ON COLUMN channels.channel_desc IS
    'e.g. telesales, internet, catalog';

COMMENT ON COLUMN channels.channel_class IS
    'e.g. direct, indirect';

ALTER TABLE channels ADD CONSTRAINT channels_pk PRIMARY KEY ( channel_id ) NOVALIDATE;

CREATE TABLE costs (
    prod_id      NUMBER(6) NOT NULL,
    time_id      DATE NOT NULL,
    promo_id     NUMBER(6) NOT NULL,
    channel_id   NUMBER NOT NULL,
    unit_cost    NUMBER(10, 2) NOT NULL,
    unit_price   NUMBER(10, 2) NOT NULL
)
NOLOGGING

PARTITION BY RANGE ( time_id ) ( PARTITION costs_1995 VALUES LESS THAN ( to_date ( &apos; 1996-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_1996 VALUES LESS THAN ( TO_DATE(&apos; 1997-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_H1_1997 VALUES LESS THAN ( TO_DATE(&apos; 1997-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_H2_1997 VALUES LESS THAN ( TO_DATE(&apos; 1998-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q1_1998 VALUES LESS THAN ( TO_DATE(&apos; 1998-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q2_1998 VALUES LESS THAN ( TO_DATE(&apos; 1998-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q3_1998 VALUES LESS THAN ( TO_DATE(&apos; 1998-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q4_1998 VALUES LESS THAN ( TO_DATE(&apos; 1999-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q1_1999 VALUES LESS THAN ( TO_DATE(&apos; 1999-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q2_1999 VALUES LESS THAN ( TO_DATE(&apos; 1999-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q3_1999 VALUES LESS THAN ( TO_DATE(&apos; 1999-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q4_1999 VALUES LESS THAN ( TO_DATE(&apos; 2000-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q1_2000 VALUES LESS THAN ( TO_DATE(&apos; 2000-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q2_2000 VALUES LESS THAN ( TO_DATE(&apos; 2000-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q3_2000 VALUES LESS THAN ( TO_DATE(&apos; 2000-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q4_2000 VALUES LESS THAN ( TO_DATE(&apos; 2001-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q1_2001 VALUES LESS THAN ( TO_DATE(&apos; 2001-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q2_2001 VALUES LESS THAN ( TO_DATE(&apos; 2001-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q3_2001 VALUES LESS THAN ( TO_DATE(&apos; 2001-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q4_2001 VALUES LESS THAN ( TO_DATE(&apos; 2002-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q1_2002 VALUES LESS THAN ( TO_DATE(&apos; 2002-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q2_2002 VALUES LESS THAN ( TO_DATE(&apos; 2002-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q4_2002 VALUES LESS THAN ( TO_DATE(&apos; 2003-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q1_2003 VALUES LESS THAN ( TO_DATE(&apos; 2003-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q2_2003 VALUES LESS THAN ( TO_DATE(&apos; 2003-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q3_2003 VALUES LESS THAN ( TO_DATE(&apos; 2003-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q3_2002 VALUES LESS THAN ( TO_DATE(&apos; 2002-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION COSTS_Q4_2003 VALUES LESS THAN ( TO_DATE(&apos; 2004-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;, &apos;nls_calendar = gregorian&apos;) )
nologging ) 
;
CREATE BITMAP INDEX costs_prod_bix ON
    costs (
        prod_id
    ASC )
            LOCAL ( PARTITION costs_1995,
                PARTITION costs_1996,
                PARTITION costs_h1_1997,
                PARTITION costs_h2_1997,
                PARTITION costs_q1_1998,
                PARTITION costs_q2_1998,
                PARTITION costs_q3_1998,
                PARTITION costs_q4_1998,
                PARTITION costs_q1_1999,
                PARTITION costs_q2_1999,
                PARTITION costs_q3_1999,
                PARTITION costs_q4_1999,
                PARTITION costs_q1_2000,
                PARTITION costs_q2_2000,
                PARTITION costs_q3_2000,
                PARTITION costs_q4_2000,
                PARTITION costs_q1_2001,
                PARTITION costs_q2_2001,
                PARTITION costs_q3_2001,
                PARTITION costs_q4_2001,
                PARTITION costs_q1_2002,
                PARTITION costs_q2_2002,
                PARTITION costs_q4_2002,
                PARTITION costs_q1_2003,
                PARTITION costs_q2_2003,
                PARTITION costs_q3_2003,
                PARTITION costs_q3_2002,
                PARTITION costs_q4_2003 )
        LOGGING;

CREATE BITMAP INDEX costs_time_bix ON
    costs (
        time_id
    ASC )
            LOCAL ( PARTITION costs_1995,
                PARTITION costs_1996,
                PARTITION costs_h1_1997,
                PARTITION costs_h2_1997,
                PARTITION costs_q1_1998,
                PARTITION costs_q2_1998,
                PARTITION costs_q3_1998,
                PARTITION costs_q4_1998,
                PARTITION costs_q1_1999,
                PARTITION costs_q2_1999,
                PARTITION costs_q3_1999,
                PARTITION costs_q4_1999,
                PARTITION costs_q1_2000,
                PARTITION costs_q2_2000,
                PARTITION costs_q3_2000,
                PARTITION costs_q4_2000,
                PARTITION costs_q1_2001,
                PARTITION costs_q2_2001,
                PARTITION costs_q3_2001,
                PARTITION costs_q4_2001,
                PARTITION costs_q1_2002,
                PARTITION costs_q2_2002,
                PARTITION costs_q4_2002,
                PARTITION costs_q1_2003,
                PARTITION costs_q2_2003,
                PARTITION costs_q3_2003,
                PARTITION costs_q3_2002,
                PARTITION costs_q4_2003 )
        LOGGING;

CREATE TABLE countries (
    country_id             NUMBER NOT NULL,
    country_iso_code       CHAR(2 BYTE) NOT NULL,
    country_name           VARCHAR2(40 BYTE) NOT NULL,
    country_subregion      VARCHAR2(30 BYTE) NOT NULL,
    country_subregion_id   NUMBER NOT NULL,
    country_region         VARCHAR2(20 BYTE) NOT NULL,
    country_region_id      NUMBER NOT NULL,
    country_total          VARCHAR2(11 BYTE) NOT NULL,
    country_total_id       NUMBER NOT NULL,
    country_name_hist      VARCHAR2(40 BYTE)
)
LOGGING
    ENABLE ROW MOVEMENT;

COMMENT ON COLUMN countries.country_id IS
    'primary key';

COMMENT ON COLUMN countries.country_name IS
    'country name';

COMMENT ON COLUMN countries.country_subregion IS
    'e.g. Western Europe, to allow hierarchies';

COMMENT ON COLUMN countries.country_region IS
    'e.g. Europe, Asia';

ALTER TABLE countries ADD CONSTRAINT countries_pk PRIMARY KEY ( country_id ) NOVALIDATE;

CREATE TABLE customers (
    cust_id                  NUMBER NOT NULL,
    cust_first_name          VARCHAR2(20 BYTE) NOT NULL,
    cust_last_name           VARCHAR2(40 BYTE) NOT NULL,
    cust_gender              CHAR(1 BYTE) NOT NULL,
    cust_year_of_birth       NUMBER(4) NOT NULL,
    cust_marital_status      VARCHAR2(20 BYTE),
    cust_street_address      VARCHAR2(40 BYTE) NOT NULL,
    cust_postal_code         VARCHAR2(10 BYTE) NOT NULL,
    cust_city                VARCHAR2(30 BYTE) NOT NULL,
    cust_city_id             NUMBER NOT NULL,
    cust_state_province      VARCHAR2(40 BYTE) NOT NULL,
    cust_state_province_id   NUMBER NOT NULL,
    country_id               NUMBER NOT NULL,
    cust_main_phone_number   VARCHAR2(25 BYTE) NOT NULL,
    cust_income_level        VARCHAR2(30 BYTE),
    cust_credit_limit        NUMBER,
    cust_email               VARCHAR2(30 BYTE),
    cust_total               VARCHAR2(14 BYTE) NOT NULL,
    cust_total_id            NUMBER NOT NULL,
    cust_src_id              NUMBER,
    cust_eff_from            DATE,
    cust_eff_to              DATE,
    cust_valid               VARCHAR2(1 BYTE)
)
LOGGING
    ENABLE ROW MOVEMENT;

COMMENT ON COLUMN customers.cust_id IS
    'primary key';

COMMENT ON COLUMN customers.cust_first_name IS
    'first name of the customer';

COMMENT ON COLUMN customers.cust_last_name IS
    'last name of the customer';

COMMENT ON COLUMN customers.cust_gender IS
    'gender; low cardinality attribute';

COMMENT ON COLUMN customers.cust_year_of_birth IS
    'customer year of birth';

COMMENT ON COLUMN customers.cust_marital_status IS
    'customer marital status; low cardinality attribute';

COMMENT ON COLUMN customers.cust_street_address IS
    'customer street address';

COMMENT ON COLUMN customers.cust_postal_code IS
    'postal code of the customer';

COMMENT ON COLUMN customers.cust_city IS
    'city where the customer lives';

COMMENT ON COLUMN customers.cust_state_province IS
    'customer geography: state or province';

COMMENT ON COLUMN customers.country_id IS
    'foreign key to the countries table (snowflake)';

COMMENT ON COLUMN customers.cust_main_phone_number IS
    'customer main phone number';

COMMENT ON COLUMN customers.cust_income_level IS
    'customer income level';

COMMENT ON COLUMN customers.cust_credit_limit IS
    'customer credit limit';

COMMENT ON COLUMN customers.cust_email IS
    'customer email id';

CREATE BITMAP INDEX customers_gender_bix ON
    customers (
        cust_gender
    ASC )
        LOGGING;

CREATE BITMAP INDEX customers_marital_bix ON
    customers (
        cust_marital_status
    ASC )
        LOGGING;

CREATE BITMAP INDEX customers_yob_bix ON
    customers (
        cust_year_of_birth
    ASC )
        LOGGING;

ALTER TABLE customers ADD CONSTRAINT customers_pk PRIMARY KEY ( cust_id ) NOVALIDATE;

CREATE TABLE dimension_exceptions (
    statement_id     VARCHAR2(30 BYTE),
    owner            VARCHAR2(30 BYTE) NOT NULL,
    table_name       VARCHAR2(30 BYTE) NOT NULL,
    dimension_name   VARCHAR2(30 BYTE) NOT NULL,
    relationship     VARCHAR2(11 BYTE) NOT NULL,
    bad_rowid        ROWID NOT NULL
)
LOGGING
    ENABLE ROW MOVEMENT;

CREATE TABLE mlog$_products (
    prod_id           NUMBER(6),
    sequence$$        NUMBER,
    snaptime$$        DATE,
    dmltype$$         VARCHAR2(1 BYTE),
    old_new$$         VARCHAR2(1 BYTE),
    change_vector$$   RAW(255)
)
LOGGING
        PARALLEL
    ENABLE ROW MOVEMENT;

CREATE TABLE mlog$_sales (
    prod_id           NUMBER,
    cust_id           NUMBER,
    time_id           DATE,
    channel_id        NUMBER,
    promo_id          NUMBER,
    quantity_sold     NUMBER(10, 2),
    amount_sold       NUMBER(10, 2),
    m_row$$           VARCHAR2(255 BYTE),
    sequence$$        NUMBER,
    snaptime$$        DATE,
    dmltype$$         VARCHAR2(1 BYTE),
    old_new$$         VARCHAR2(1 BYTE),
    change_vector$$   RAW(255)
)
LOGGING
    ENABLE ROW MOVEMENT;

CREATE TABLE products (
    prod_id                 NUMBER(6) NOT NULL,
    prod_name               VARCHAR2(50 BYTE) NOT NULL,
    prod_desc               VARCHAR2(4000 BYTE) NOT NULL,
    prod_subcategory        VARCHAR2(50 BYTE) NOT NULL,
    prod_subcategory_id     NUMBER NOT NULL,
    prod_subcategory_desc   VARCHAR2(2000 BYTE) NOT NULL,
    prod_category           VARCHAR2(50 BYTE) NOT NULL,
    prod_category_id        NUMBER NOT NULL,
    prod_category_desc      VARCHAR2(2000 BYTE) NOT NULL,
    prod_weight_class       NUMBER(3) NOT NULL,
    prod_unit_of_measure    VARCHAR2(20 BYTE),
    prod_pack_size          VARCHAR2(30 BYTE) NOT NULL,
    supplier_id             NUMBER(6) NOT NULL,
    prod_status             VARCHAR2(20 BYTE) NOT NULL,
    prod_list_price         NUMBER(8, 2) NOT NULL,
    prod_min_price          NUMBER(8, 2) NOT NULL,
    prod_total              VARCHAR2(13 BYTE) NOT NULL,
    prod_total_id           NUMBER NOT NULL,
    prod_src_id             NUMBER,
    prod_eff_from           DATE,
    prod_eff_to             DATE,
    prod_valid              VARCHAR2(1 BYTE)
)
LOGGING
    ENABLE ROW MOVEMENT;

COMMENT ON COLUMN products.prod_id IS
    'primary key';

COMMENT ON COLUMN products.prod_name IS
    'product name';

COMMENT ON COLUMN products.prod_desc IS
    'product description';

COMMENT ON COLUMN products.prod_subcategory IS
    'product subcategory';

COMMENT ON COLUMN products.prod_subcategory_desc IS
    'product subcategory description';

COMMENT ON COLUMN products.prod_category IS
    'product category';

COMMENT ON COLUMN products.prod_category_desc IS
    'product category description';

COMMENT ON COLUMN products.prod_weight_class IS
    'product weight class';

COMMENT ON COLUMN products.prod_unit_of_measure IS
    'product unit of measure';

COMMENT ON COLUMN products.prod_pack_size IS
    'product package size';

COMMENT ON COLUMN products.supplier_id IS
    'this column';

COMMENT ON COLUMN products.prod_status IS
    'product status';

COMMENT ON COLUMN products.prod_list_price IS
    'product list price';

COMMENT ON COLUMN products.prod_min_price IS
    'product minimum price';

CREATE BITMAP INDEX products_prod_status_bix ON
    products (
        prod_status
    ASC )
        LOGGING;

CREATE INDEX products_prod_subcat_ix ON
    products (
        prod_subcategory
    ASC )
        LOGGING;

CREATE INDEX products_prod_cat_ix ON
    products (
        prod_category
    ASC )
        LOGGING;

ALTER TABLE products ADD CONSTRAINT products_pk PRIMARY KEY ( prod_id ) NOVALIDATE;

CREATE TABLE promotions (
    promo_id               NUMBER(6) NOT NULL,
    promo_name             VARCHAR2(30 BYTE) NOT NULL,
    promo_subcategory      VARCHAR2(30 BYTE) NOT NULL,
    promo_subcategory_id   NUMBER NOT NULL,
    promo_category         VARCHAR2(30 BYTE) NOT NULL,
    promo_category_id      NUMBER NOT NULL,
    promo_cost             NUMBER(10, 2) NOT NULL,
    promo_begin_date       DATE NOT NULL,
    promo_end_date         DATE NOT NULL,
    promo_total            VARCHAR2(15 BYTE) NOT NULL,
    promo_total_id         NUMBER NOT NULL
)
LOGGING
    ENABLE ROW MOVEMENT;

COMMENT ON COLUMN promotions.promo_id IS
    'primary key column';

COMMENT ON COLUMN promotions.promo_name IS
    'promotion description';

COMMENT ON COLUMN promotions.promo_subcategory IS
    'enables to investigate promotion hierarchies';

COMMENT ON COLUMN promotions.promo_category IS
    'promotion category';

COMMENT ON COLUMN promotions.promo_cost IS
    'promotion cost, to do promotion effect calculations';

COMMENT ON COLUMN promotions.promo_begin_date IS
    'promotion begin day';

COMMENT ON COLUMN promotions.promo_end_date IS
    'promotion end day';

ALTER TABLE promotions ADD CONSTRAINT promo_pk PRIMARY KEY ( promo_id ) NOVALIDATE;

CREATE TABLE real_time_monitoring (
    report CLOB
)
NOLOGGING
        LOB ( report ) STORE AS ls1 (
            STORAGE ( PCTINCREASE 0 MINEXTENTS 1 MAXEXTENTS UNLIMITED FREELISTS 1 BUFFER_POOL DEFAULT )
            CHUNK 8192
            RETENTION
            ENABLE STORAGE IN ROW
            NOCACHE NOLOGGING
        )
    ENABLE ROW MOVEMENT;

CREATE GLOBAL TEMPORARY TABLE rupd$_products (
    prod_id           NUMBER(6),
    dmltype$$         VARCHAR2(1 BYTE),
    snapid            NUMBER(38),
    change_vector$$   RAW(255)
) ON COMMIT PRESERVE ROWS
    ENABLE ROW MOVEMENT;

CREATE TABLE sales (
    prod_id         NUMBER(6) NOT NULL,
    cust_id         NUMBER NOT NULL,
    time_id         DATE NOT NULL,
    channel_id      NUMBER NOT NULL,
    promo_id        NUMBER(6) NOT NULL,
    quantity_sold   NUMBER(10, 2) NOT NULL,
    amount_sold     NUMBER(10, 2) NOT NULL
)
NOLOGGING

PARTITION BY RANGE ( time_id ) ( PARTITION sales_1995 VALUES LESS THAN ( to_date ( &apos; 1996-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_1996 VALUES LESS THAN ( TO_DATE(&apos; 1997-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_H1_1997 VALUES LESS THAN ( TO_DATE(&apos; 1997-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_H2_1997 VALUES LESS THAN ( TO_DATE(&apos; 1998-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q1_1998 VALUES LESS THAN ( TO_DATE(&apos; 1998-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q2_1998 VALUES LESS THAN ( TO_DATE(&apos; 1998-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q3_1998 VALUES LESS THAN ( TO_DATE(&apos; 1998-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q4_1998 VALUES LESS THAN ( TO_DATE(&apos; 1999-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q1_1999 VALUES LESS THAN ( TO_DATE(&apos; 1999-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q2_1999 VALUES LESS THAN ( TO_DATE(&apos; 1999-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q3_1999 VALUES LESS THAN ( TO_DATE(&apos; 1999-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q4_1999 VALUES LESS THAN ( TO_DATE(&apos; 2000-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q1_2000 VALUES LESS THAN ( TO_DATE(&apos; 2000-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q2_2000 VALUES LESS THAN ( TO_DATE(&apos; 2000-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q3_2000 VALUES LESS THAN ( TO_DATE(&apos; 2000-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q4_2000 VALUES LESS THAN ( TO_DATE(&apos; 2001-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q1_2001 VALUES LESS THAN ( TO_DATE(&apos; 2001-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q2_2001 VALUES LESS THAN ( TO_DATE(&apos; 2001-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q3_2001 VALUES LESS THAN ( TO_DATE(&apos; 2001-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q4_2001 VALUES LESS THAN ( TO_DATE(&apos; 2002-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q1_2002 VALUES LESS THAN ( TO_DATE(&apos; 2002-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q3_2002 VALUES LESS THAN ( TO_DATE(&apos; 2002-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q4_2002 VALUES LESS THAN ( TO_DATE(&apos; 2003-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q1_2003 VALUES LESS THAN ( TO_DATE(&apos; 2003-04-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q2_2003 VALUES LESS THAN ( TO_DATE(&apos; 2003-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q3_2003 VALUES LESS THAN ( TO_DATE(&apos; 2003-10-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q2_2002 VALUES LESS THAN ( TO_DATE(&apos; 2002-07-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;,&apos;NLS_CALENDAR=GREGORIAN&apos;) ) 
        NOLOGGING , 
    PARTITION SALES_Q4_2003 VALUES LESS THAN ( TO_DATE(&apos; 2004-01-01 00:00:00&apos;,&apos;SYYYY-MM-DD HH24:MI:SS&apos;, &apos;nls_calendar = gregorian&apos;) )
nologging ) 
;
COMMENT ON COLUMN sales.prod_id IS
    'FK to the products dimension table';

COMMENT ON COLUMN sales.cust_id IS
    'FK to the customers dimension table';

COMMENT ON COLUMN sales.time_id IS
    'FK to the times dimension table';

COMMENT ON COLUMN sales.channel_id IS
    'FK to the channels dimension table';

COMMENT ON COLUMN sales.promo_id IS
    'promotion identifier, without FK constraint (intentionally) to show outer join optimization';

COMMENT ON COLUMN sales.quantity_sold IS
    'product quantity sold with the transaction';

COMMENT ON COLUMN sales.amount_sold IS
    'invoiced amount to the customer';

CREATE INDEX cost_ix ON
    sales (
        amount_sold
    ASC )
        LOGGING;

CREATE BITMAP INDEX sales_prod_bix ON
    sales (
        prod_id
    ASC )
            LOCAL ( PARTITION sales_1995,
                PARTITION sales_1996,
                PARTITION sales_h1_1997,
                PARTITION sales_h2_1997,
                PARTITION sales_q1_1998,
                PARTITION sales_q2_1998,
                PARTITION sales_q3_1998,
                PARTITION sales_q4_1998,
                PARTITION sales_q1_1999,
                PARTITION sales_q2_1999,
                PARTITION sales_q3_1999,
                PARTITION sales_q4_1999,
                PARTITION sales_q1_2000,
                PARTITION sales_q2_2000,
                PARTITION sales_q3_2000,
                PARTITION sales_q4_2000,
                PARTITION sales_q1_2001,
                PARTITION sales_q2_2001,
                PARTITION sales_q3_2001,
                PARTITION sales_q4_2001,
                PARTITION sales_q1_2002,
                PARTITION sales_q3_2002,
                PARTITION sales_q4_2002,
                PARTITION sales_q1_2003,
                PARTITION sales_q2_2003,
                PARTITION sales_q3_2003,
                PARTITION sales_q2_2002,
                PARTITION sales_q4_2003 )
        LOGGING;

CREATE BITMAP INDEX sales_cust_bix ON
    sales (
        cust_id
    ASC )
            LOCAL ( PARTITION sales_1995,
                PARTITION sales_1996,
                PARTITION sales_h1_1997,
                PARTITION sales_h2_1997,
                PARTITION sales_q1_1998,
                PARTITION sales_q2_1998,
                PARTITION sales_q3_1998,
                PARTITION sales_q4_1998,
                PARTITION sales_q1_1999,
                PARTITION sales_q2_1999,
                PARTITION sales_q3_1999,
                PARTITION sales_q4_1999,
                PARTITION sales_q1_2000,
                PARTITION sales_q2_2000,
                PARTITION sales_q3_2000,
                PARTITION sales_q4_2000,
                PARTITION sales_q1_2001,
                PARTITION sales_q2_2001,
                PARTITION sales_q3_2001,
                PARTITION sales_q4_2001,
                PARTITION sales_q1_2002,
                PARTITION sales_q3_2002,
                PARTITION sales_q4_2002,
                PARTITION sales_q1_2003,
                PARTITION sales_q2_2003,
                PARTITION sales_q3_2003,
                PARTITION sales_q2_2002,
                PARTITION sales_q4_2003 )
        LOGGING;

CREATE BITMAP INDEX sales_time_bix ON
    sales (
        time_id
    ASC )
            LOCAL ( PARTITION sales_1995,
                PARTITION sales_1996,
                PARTITION sales_h1_1997,
                PARTITION sales_h2_1997,
                PARTITION sales_q1_1998,
                PARTITION sales_q2_1998,
                PARTITION sales_q3_1998,
                PARTITION sales_q4_1998,
                PARTITION sales_q1_1999,
                PARTITION sales_q2_1999,
                PARTITION sales_q3_1999,
                PARTITION sales_q4_1999,
                PARTITION sales_q1_2000,
                PARTITION sales_q2_2000,
                PARTITION sales_q3_2000,
                PARTITION sales_q4_2000,
                PARTITION sales_q1_2001,
                PARTITION sales_q2_2001,
                PARTITION sales_q3_2001,
                PARTITION sales_q4_2001,
                PARTITION sales_q1_2002,
                PARTITION sales_q3_2002,
                PARTITION sales_q4_2002,
                PARTITION sales_q1_2003,
                PARTITION sales_q2_2003,
                PARTITION sales_q3_2003,
                PARTITION sales_q2_2002,
                PARTITION sales_q4_2003 )
        LOGGING;

CREATE BITMAP INDEX sales_channel_bix ON
    sales (
        channel_id
    ASC )
            LOCAL ( PARTITION sales_1995,
                PARTITION sales_1996,
                PARTITION sales_h1_1997,
                PARTITION sales_h2_1997,
                PARTITION sales_q1_1998,
                PARTITION sales_q2_1998,
                PARTITION sales_q3_1998,
                PARTITION sales_q4_1998,
                PARTITION sales_q1_1999,
                PARTITION sales_q2_1999,
                PARTITION sales_q3_1999,
                PARTITION sales_q4_1999,
                PARTITION sales_q1_2000,
                PARTITION sales_q2_2000,
                PARTITION sales_q3_2000,
                PARTITION sales_q4_2000,
                PARTITION sales_q1_2001,
                PARTITION sales_q2_2001,
                PARTITION sales_q3_2001,
                PARTITION sales_q4_2001,
                PARTITION sales_q1_2002,
                PARTITION sales_q3_2002,
                PARTITION sales_q4_2002,
                PARTITION sales_q1_2003,
                PARTITION sales_q2_2003,
                PARTITION sales_q3_2003,
                PARTITION sales_q2_2002,
                PARTITION sales_q4_2003 )
        LOGGING;

CREATE BITMAP INDEX sales_promo_bix ON
    sales (
        promo_id
    ASC )
            LOCAL ( PARTITION sales_1995,
                PARTITION sales_1996,
                PARTITION sales_h1_1997,
                PARTITION sales_h2_1997,
                PARTITION sales_q1_1998,
                PARTITION sales_q2_1998,
                PARTITION sales_q3_1998,
                PARTITION sales_q4_1998,
                PARTITION sales_q1_1999,
                PARTITION sales_q2_1999,
                PARTITION sales_q3_1999,
                PARTITION sales_q4_1999,
                PARTITION sales_q1_2000,
                PARTITION sales_q2_2000,
                PARTITION sales_q3_2000,
                PARTITION sales_q4_2000,
                PARTITION sales_q1_2001,
                PARTITION sales_q2_2001,
                PARTITION sales_q3_2001,
                PARTITION sales_q4_2001,
                PARTITION sales_q1_2002,
                PARTITION sales_q3_2002,
                PARTITION sales_q4_2002,
                PARTITION sales_q1_2003,
                PARTITION sales_q2_2003,
                PARTITION sales_q3_2003,
                PARTITION sales_q2_2002,
                PARTITION sales_q4_2003 )
        LOGGING;

CREATE TABLE sales_transactions_ext (
    amount_sold     NUMBER(10, 2),
    channel_id      NUMBER(22),
    cust_id         NUMBER(22),
    prod_id         NUMBER(22),
    promo_id        NUMBER(22),
    quantity_sold   NUMBER(22),
    time_id         DATE,
    unit_cost       NUMBER(10, 2),
    unit_price      NUMBER(10, 2)
)

organization EXTERNAL ( TYPE oracle_loader ACCESS PARAMETERS USING CLOB RECORDS DELIMITED BY NEWLINE CHARACTERSET US7ASCII &lt;br&gt; TERRITORY AMERICAN &lt;br&gt; BADFILE log_file_dir:&apos;ext_1v3.bad&apos; &lt;br&gt; LOGFILE log_file_dir:&apos;ext_1v3.log&apos; &lt;br&gt; FIELDS TERMINATED BY &quot;|&quot; OPTIONALLY ENCLOSED BY &apos; &apos; LDRTRIM &lt;br&gt; ( PROD_ID,&lt;br&gt; CUST_ID,&lt;br&gt; TIME_ID         DATE(10) &quot;YYYY-MM-DD&quot;,&lt;br&gt; CHANNEL_ID,&lt;br&gt; PROMO_ID,&lt;br&gt; QUANTITY_SOLD,&lt;br&gt; AMOUNT_SOLD,&lt;br&gt; UNIT_COST,&lt;br&gt; UNIT_PRICE &lt;br&gt; )
    LOCATION ( 'sale1v3.dat' )
) REJECT LIMIT 100 
;

CREATE TABLE supplementary_demographics (
    cust_id                   NUMBER NOT NULL,
    education                 VARCHAR2(21 BYTE),
    occupation                VARCHAR2(21 BYTE),
    household_size            VARCHAR2(21 BYTE),
    yrs_residence             NUMBER,
    affinity_card             NUMBER(10),
    bulk_pack_diskettes       NUMBER(10),
    flat_panel_monitor        NUMBER(10),
    home_theater_package      NUMBER(10),
    bookkeeping_application   NUMBER(10),
    printer_supplies          NUMBER(10),
    y_box_games               NUMBER(10),
    os_doc_set_kanji          NUMBER(10),
    comments                  VARCHAR2(4000 BYTE)
)
LOGGING
    ENABLE ROW MOVEMENT;

CREATE INDEX sup_text_idx ON
    supplementary_demographics (
        comments
    ASC )
        LOGGING;

ALTER TABLE supplementary_demographics ADD CONSTRAINT supp_demo_pk PRIMARY KEY ( cust_id ) DISABLE NOVALIDATE;

CREATE TABLE times (
    time_id                   DATE NOT NULL,
    day_name                  VARCHAR2(9 BYTE) NOT NULL,
    day_number_in_week        NUMBER(1) NOT NULL,
    day_number_in_month       NUMBER(2) NOT NULL,
    calendar_week_number      NUMBER(2) NOT NULL,
    fiscal_week_number        NUMBER(2) NOT NULL,
    week_ending_day           DATE NOT NULL,
    week_ending_day_id        NUMBER NOT NULL,
    calendar_month_number     NUMBER(2) NOT NULL,
    fiscal_month_number       NUMBER(2) NOT NULL,
    calendar_month_desc       VARCHAR2(8 BYTE) NOT NULL,
    calendar_month_id         NUMBER NOT NULL,
    fiscal_month_desc         VARCHAR2(8 BYTE) NOT NULL,
    fiscal_month_id           NUMBER NOT NULL,
    days_in_cal_month         NUMBER NOT NULL,
    days_in_fis_month         NUMBER NOT NULL,
    end_of_cal_month          DATE NOT NULL,
    end_of_fis_month          DATE NOT NULL,
    calendar_month_name       VARCHAR2(9 BYTE) NOT NULL,
    fiscal_month_name         VARCHAR2(9 BYTE) NOT NULL,
    calendar_quarter_desc     CHAR(7 BYTE) NOT NULL,
    calendar_quarter_id       NUMBER NOT NULL,
    fiscal_quarter_desc       CHAR(7 BYTE) NOT NULL,
    fiscal_quarter_id         NUMBER NOT NULL,
    days_in_cal_quarter       NUMBER NOT NULL,
    days_in_fis_quarter       NUMBER NOT NULL,
    end_of_cal_quarter        DATE NOT NULL,
    end_of_fis_quarter        DATE NOT NULL,
    calendar_quarter_number   NUMBER(1) NOT NULL,
    fiscal_quarter_number     NUMBER(1) NOT NULL,
    calendar_year             NUMBER(4) NOT NULL,
    calendar_year_id          NUMBER NOT NULL,
    fiscal_year               NUMBER(4) NOT NULL,
    fiscal_year_id            NUMBER NOT NULL,
    days_in_cal_year          NUMBER NOT NULL,
    days_in_fis_year          NUMBER NOT NULL,
    end_of_cal_year           DATE NOT NULL,
    end_of_fis_year           DATE NOT NULL
)
LOGGING
    ENABLE ROW MOVEMENT;

COMMENT ON COLUMN times.time_id IS
    'primary key; day date, finest granularity, CORRECT ORDER';

COMMENT ON COLUMN times.day_name IS
    'Monday to Sunday, repeating';

COMMENT ON COLUMN times.day_number_in_week IS
    '1 to 7, repeating';

COMMENT ON COLUMN times.day_number_in_month IS
    '1 to 31, repeating';

COMMENT ON COLUMN times.calendar_week_number IS
    '1 to 53, repeating';

COMMENT ON COLUMN times.fiscal_week_number IS
    '1 to 53, repeating';

COMMENT ON COLUMN times.week_ending_day IS
    'date of last day in week, CORRECT ORDER';

COMMENT ON COLUMN times.calendar_month_number IS
    '1 to 12, repeating';

COMMENT ON COLUMN times.fiscal_month_number IS
    '1 to 12, repeating';

COMMENT ON COLUMN times.calendar_month_desc IS
    'e.g. 1998-01, CORRECT ORDER';

COMMENT ON COLUMN times.fiscal_month_desc IS
    'e.g. 1998-01, CORRECT ORDER';

COMMENT ON COLUMN times.days_in_cal_month IS
    'e.g. 28,31, repeating';

COMMENT ON COLUMN times.days_in_fis_month IS
    'e.g. 25,32, repeating';

COMMENT ON COLUMN times.end_of_cal_month IS
    'last day of calendar month';

COMMENT ON COLUMN times.end_of_fis_month IS
    'last day of fiscal month';

COMMENT ON COLUMN times.calendar_month_name IS
    'January to December, repeating';

COMMENT ON COLUMN times.fiscal_month_name IS
    'January to December, repeating';

COMMENT ON COLUMN times.calendar_quarter_desc IS
    'e.g. 1998-Q1, CORRECT ORDER';

COMMENT ON COLUMN times.fiscal_quarter_desc IS
    'e.g. 1999-Q3, CORRECT ORDER';

COMMENT ON COLUMN times.days_in_cal_quarter IS
    'e.g. 88,90, repeating';

COMMENT ON COLUMN times.days_in_fis_quarter IS
    'e.g. 88,90, repeating';

COMMENT ON COLUMN times.end_of_cal_quarter IS
    'last day of calendar quarter';

COMMENT ON COLUMN times.end_of_fis_quarter IS
    'last day of fiscal quarter';

COMMENT ON COLUMN times.calendar_quarter_number IS
    '1 to 4, repeating';

COMMENT ON COLUMN times.fiscal_quarter_number IS
    '1 to 4, repeating';

COMMENT ON COLUMN times.calendar_year IS
    'e.g. 1999, CORRECT ORDER';

COMMENT ON COLUMN times.fiscal_year IS
    'e.g. 1999, CORRECT ORDER';

COMMENT ON COLUMN times.days_in_cal_year IS
    '365,366 repeating';

COMMENT ON COLUMN times.days_in_fis_year IS
    'e.g. 355,364, repeating';

COMMENT ON COLUMN times.end_of_cal_year IS
    'last day of cal year';

COMMENT ON COLUMN times.end_of_fis_year IS
    'last day of fiscal year';

ALTER TABLE times ADD CONSTRAINT times_pk PRIMARY KEY ( time_id ) NOVALIDATE;

CREATE MATERIALIZED VIEW cal_month_sales_mv (
    calendar_month_desc,
    dollars
)
LOGGING AS SELECT
    t.calendar_month_desc &lt;br&gt; ,        sum(s.amount_sold) AS dollars &lt;br&gt; FROM     sales s &lt;br&gt; ,        times t &lt;br&gt; WHERE    s.time_id = t.time_id &lt; br&gt;
    group by t.calendar_month_desc;

CREATE MATERIALIZED VIEW fweek_pscat_sales_mv (
    week_ending_day,
    prod_subcategory,
    dollars,
    channel_id,
    promo_id
)
LOGGING AS SELECT
    t.week_ending_day &lt;br&gt; ,        p.prod_subcategory &lt;br&gt; ,        sum(s.amount_sold) AS dollars &lt;br&gt; ,        s.channel_id &lt;br&gt; ,        s.promo_id &lt;br&gt; FROM     sales s &lt;br&gt; ,        times t &lt;br&gt; ,        products p &lt;br&gt; WHERE    s.time_id = t.time_id &lt;br&gt; AND      s.prod_id = p.prod_id &lt;br&gt; GROUP BY t.week_ending_day &lt;br&gt; ,        p.prod_subcategory &lt;br&gt; ,        s.channel_id &lt;br&gt;,
s.promo_id;

CREATE BITMAP INDEX fw_psc_s_mv_subcat_bix ON
    fweek_pscat_sales_mv (
        prod_subcategory
    ASC )
        LOGGING;

CREATE BITMAP INDEX fw_psc_s_mv_chan_bix ON
    fweek_pscat_sales_mv (
        channel_id
    ASC )
        LOGGING;

CREATE BITMAP INDEX fw_psc_s_mv_promo_bix ON
    fweek_pscat_sales_mv (
        promo_id
    ASC )
        LOGGING;

CREATE BITMAP INDEX fw_psc_s_mv_wd_bix ON
    fweek_pscat_sales_mv (
        week_ending_day
    ASC )
        LOGGING;

ALTER TABLE costs
    ADD CONSTRAINT costs_channel_fk FOREIGN KEY ( channel_id )
        REFERENCES channels ( channel_id )
    NOT DEFERRABLE;

ALTER TABLE costs
    ADD CONSTRAINT costs_product_fk FOREIGN KEY ( prod_id )
        REFERENCES products ( prod_id )
    NOT DEFERRABLE;

ALTER TABLE costs
    ADD CONSTRAINT costs_promo_fk FOREIGN KEY ( promo_id )
        REFERENCES promotions ( promo_id )
    NOT DEFERRABLE;

ALTER TABLE costs
    ADD CONSTRAINT costs_time_fk FOREIGN KEY ( time_id )
        REFERENCES times ( time_id )
    NOT DEFERRABLE;

ALTER TABLE customers
    ADD CONSTRAINT customers_country_fk FOREIGN KEY ( country_id )
        REFERENCES countries ( country_id )
    NOT DEFERRABLE;

ALTER TABLE sales
    ADD CONSTRAINT sales_channel_fk FOREIGN KEY ( channel_id )
        REFERENCES channels ( channel_id )
    NOT DEFERRABLE;

ALTER TABLE sales
    ADD CONSTRAINT sales_customer_fk FOREIGN KEY ( cust_id )
        REFERENCES customers ( cust_id )
    NOT DEFERRABLE;

ALTER TABLE sales
    ADD CONSTRAINT sales_product_fk FOREIGN KEY ( prod_id )
        REFERENCES products ( prod_id )
    NOT DEFERRABLE;

ALTER TABLE sales
    ADD CONSTRAINT sales_promo_fk FOREIGN KEY ( promo_id )
        REFERENCES promotions ( promo_id )
    NOT DEFERRABLE;

ALTER TABLE sales
    ADD CONSTRAINT sales_time_fk FOREIGN KEY ( time_id )
        REFERENCES times ( time_id )
    NOT DEFERRABLE;

CREATE OR REPLACE VIEW PROFITS  AS
&lt;br&gt; AS &lt;br&gt; SELECT &lt;br&gt; s.channel_id,&lt;br&gt; s.cust_id,&lt;br&gt; s.prod_id,&lt;br&gt; s.promo_id,&lt;br&gt; s.time_id,&lt;br&gt; c.unit_cost,&lt;br&gt; c.unit_price,&lt;br&gt; s.amount_sold,&lt;br&gt; s.quantity_sold,&lt;br&gt; c.unit_cost * s.quantity_sold TOTAL_COST &lt;br&gt; FROM &lt;br&gt; costs c,sales s &lt;br&gt; WHERE c.prod_id = s.prod_id &lt;br&gt; AND c.time_id = s.time_id &lt;br&gt; AND c.channel_id = s.channel_id &lt;br&gt; AND c.promo_id = s.promo_id 
;

CREATE OR REPLACE VIEW QUANTITIES_SOLD  AS
&lt;br&gt; AS &lt;br&gt; SELECT &quot;COUNTRIES&quot;.&quot;COUNTRY_NAME&quot;,&quot;PRODUCTS&quot;.&quot;PROD_NAME&quot;,&quot;TIMES&quot;.&quot;CALENDAR_YEAR&quot;,&quot;CUSTOMERS&quot;.&quot;CUST_LAST_NAME&quot;,&quot;SALES&quot;.&quot;QUANTITY_SOLD&quot; FROM &quot;COUNTRIES&quot;,&quot;PRODUCTS&quot;,&quot;TIMES&quot;,&quot;CUSTOMERS&quot;,&quot;SALES&quot; WHERE ( &quot;CUSTOMERS&quot;.&quot;COUNTRY_ID&quot; = &quot;COUNTRIES&quot;.&quot;COUNTRY_ID&quot; ) AND ( &quot;SALES&quot;.&quot;CUST_ID&quot; = &quot;CUSTOMERS&quot;.&quot;CUST_ID&quot; ) AND ( &quot;SALES&quot;.&quot;PROD_ID&quot; = &quot;PRODUCTS&quot;.&quot;PROD_ID&quot; ) AND ( &quot;SALES&quot;.&quot;TIME_ID&quot; = &quot;TIMES&quot;.&quot;TIME_ID&quot; ) 
;

CREATE OR REPLACE VIEW SALES_VIEW  AS
&lt;br&gt; AS &lt;br&gt; SELECT country_name country,&lt;br&gt; prod_name prod,&lt;br&gt; calendar_year year,&lt;br&gt; SUM(amount_sold) sale,&lt;br&gt; COUNT(amount_sold) cnt &lt;br&gt; FROM sales,times,customers,countries,products &lt;br&gt; WHERE sales.time_id = times.time_id AND &lt;br&gt; sales.prod_id = products.prod_id AND &lt;br&gt; sales.cust_id = customers.cust_id AND &lt;br&gt; customers.country_id = countries.country_id AND &lt;br&gt; ( customers.country_id = 52779 OR &lt;br&gt; customers.country_id = 52776 ) AND &lt;br&gt; ( prod_name = &apos;Standard Mouse&apos; OR &lt;br&gt; prod_name = &apos;Mouse Pad&apos; ) &lt;br&gt; GROUP BY country_name,prod_name,calendar_year 
;

CREATE DIMENSION channels_dim
    LEVEL channel IS channels.channel_id
    LEVEL channel_class IS channels.channel_class_id
    LEVEL channel_total IS channels.channel_total_id
    HIERARCHY channel_rollup ( channel
        CHILD OF channel_class
        CHILD OF channel_total
    )
ATTRIBUTE attr1 LEVEL channel_total DETERMINES
    channel_total
ATTRIBUTE attr2 LEVEL channel_class DETERMINES
    channel_class
ATTRIBUTE attr3 LEVEL channel DETERMINES
    channel_desc;

CREATE DIMENSION customers_dim
    LEVEL city IS customers.cust_city_id
    LEVEL country IS countries.country_id
    LEVEL cust_total IS customers.cust_total_id
    LEVEL customer IS customers.cust_id
    LEVEL geog_total IS countries.country_total_id
    LEVEL region IS countries.country_region_id
    LEVEL state IS customers.cust_state_province_id
    LEVEL subregion IS countries.country_subregion_id
    HIERARCHY cust_rollup ( customer
        CHILD OF city
        CHILD OF state
        CHILD OF cust_total
    )
    HIERARCHY geog_rollup ( customer
        CHILD OF city
        CHILD OF state
        CHILD OF country
        CHILD OF subregion
        CHILD OF region
        CHILD OF geog_total
        JOIN KEY
            customers.country_id
        REFERENCES country
    )
ATTRIBUTE attr10 LEVEL city DETERMINES
    cust_city
ATTRIBUTE attr11 LEVEL customer DETERMINES (
    cust_first_name,
    cust_email,
    cust_main_phone_number,
    cust_postal_code,
    cust_street_address,
    cust_credit_limit,
    cust_income_level,
    cust_year_of_birth,
    cust_marital_status,
    cust_gender,
    cust_last_name
) ATTRIBUTE attr4 LEVEL state DETERMINES
    cust_state_province
ATTRIBUTE attr5 LEVEL country DETERMINES (
    country_name,
    country_iso_code
) ATTRIBUTE attr6 LEVEL geog_total DETERMINES
    country_total
ATTRIBUTE attr7 LEVEL subregion DETERMINES
    country_subregion
ATTRIBUTE attr8 LEVEL cust_total DETERMINES
    cust_total
ATTRIBUTE attr9 LEVEL region DETERMINES
    country_region;

CREATE DIMENSION products_dim
    LEVEL category IS products.prod_category_id
    LEVEL prod_total IS products.prod_total_id
    LEVEL product IS products.prod_id
    LEVEL subcategory IS products.prod_subcategory_id
    HIERARCHY prod_rollup ( product
        CHILD OF subcategory
        CHILD OF category
        CHILD OF prod_total
    )
ATTRIBUTE attr12 LEVEL category DETERMINES (
    prod_category,
    prod_category_desc
) ATTRIBUTE attr13 LEVEL subcategory DETERMINES (
    prod_subcategory,
    prod_subcategory_desc
) ATTRIBUTE attr14 LEVEL product DETERMINES (
    prod_name,
    prod_min_price,
    prod_list_price,
    prod_status,
    prod_pack_size,
    prod_unit_of_measure,
    prod_weight_class,
    prod_desc
) ATTRIBUTE attr15 LEVEL prod_total DETERMINES
    prod_total
ATTRIBUTE attr16 LEVEL category DETERMINES
    promo_category
ATTRIBUTE attr19 LEVEL subcategory DETERMINES
    promo_subcategory;

CREATE DIMENSION promotions_dim
    LEVEL category IS promotions.promo_category_id
    LEVEL promo IS promotions.promo_id
    LEVEL promo_total IS promotions.promo_total_id
    LEVEL subcategory IS promotions.promo_subcategory_id
    HIERARCHY promo_rollup ( promo
        CHILD OF subcategory
        CHILD OF category
        CHILD OF promo_total
    )
ATTRIBUTE attr17 LEVEL promo DETERMINES (
    promo_name,
    promo_end_date,
    promo_begin_date,
    promo_cost
) ATTRIBUTE attr18 LEVEL promo_total DETERMINES
    promo_total;

CREATE DIMENSION times_dim
    LEVEL day IS times.time_id
    LEVEL fis_month IS times.fiscal_month_id
    LEVEL fis_quarter IS times.fiscal_quarter_id
    LEVEL fis_week IS times.week_ending_day_id
    LEVEL fis_year IS times.fiscal_year_id
    LEVEL month IS times.calendar_month_id
    LEVEL quarter IS times.calendar_quarter_id
    LEVEL year IS times.calendar_year_id
    HIERARCHY cal_rollup ( day
        CHILD OF month
        CHILD OF quarter
        CHILD OF year
    )
    HIERARCHY fis_rollup ( day
        CHILD OF fis_week
        CHILD OF fis_month
        CHILD OF fis_quarter
        CHILD OF fis_year
    )
ATTRIBUTE attr20 LEVEL quarter DETERMINES (
    calendar_quarter_desc,
    end_of_cal_quarter,
    days_in_cal_quarter,
    calendar_quarter_number
) ATTRIBUTE attr21 LEVEL day DETERMINES (
    day_number_in_week,
    calendar_week_number,
    day_number_in_month,
    day_name
) ATTRIBUTE attr22 LEVEL month DETERMINES (
    calendar_month_desc,
    end_of_cal_month,
    days_in_cal_month,
    calendar_month_name,
    calendar_month_number
) ATTRIBUTE attr23 LEVEL fis_year DETERMINES (
    fiscal_year,
    end_of_fis_year,
    days_in_fis_year
) ATTRIBUTE attr24 LEVEL year DETERMINES (
    calendar_year,
    end_of_cal_year,
    days_in_cal_year
) ATTRIBUTE attr25 LEVEL fis_quarter DETERMINES (
    fiscal_quarter_desc,
    end_of_fis_quarter,
    days_in_fis_quarter,
    fiscal_quarter_number
) ATTRIBUTE attr26 LEVEL fis_week DETERMINES (
    week_ending_day,
    fiscal_week_number
) ATTRIBUTE attr27 LEVEL fis_month DETERMINES (
    fiscal_month_desc,
    end_of_fis_month,
    days_in_fis_month,
    fiscal_month_name,
    fiscal_month_number
);



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                            15
-- CREATE INDEX                            19
-- ALTER TABLE                             17
-- CREATE VIEW                              3
-- ALTER VIEW                               0
-- CREATE PACKAGE                           0
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                           0
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         5
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          0
-- CREATE MATERIALIZED VIEW                 2
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
